import { Expression } from '../expression/expression'
import { ExpressionFactory } from '../expression/expressionFactory'
import { Table } from './table'

type EnumObject = { [key: string]: string | number }

/**
 * Marker for a columns default value.
 *
 * Used in the type definition and in inserts / updates similar to SQL's
 * `DEFAULT` keyword.
 */
export declare class DefaultValue {
  protected _typesafeQueryBuilderDefaultValue_: symbol
}

/**
 * A column of a table
 *
 * T .. column type
 */
export declare class Column<T> {
  // column value type
  protected __t: T

  /// Builtin Column Types

  /**
   * Map this column to a typescript number that must be an integer.
   *
   * Column values being integers is only checked when inserting or updating
   * data.
   */
  integer(): Column<number>

  /**
   * Map this column to a string.
   *
   * postgres types: TEXT, VARCHAR
   */
  string(): Column<string>

  /**
   * Map this column to a boolean.
   *
   * postgres type: BOOLEAN
   */
  boolean(): Column<boolean>

  /**
   * Map this column to a date.
   *
   * postgres types: TIMESTAMPTZ
   */
  date(): Column<Date>

  /**
   * Map this column to an json object.
   *
   * Validator should be function that validates the type of the incoming
   * data. Validator is called before inserting or updating.
   * The resulting value is JSON.stringified before being inserted into
   * postgres or passed to and update query.
   *
   * postgres types: JSON, JSONB
   */
  json<J>(validator: (data: unknown) => J): Column<J>

  /**
   * Literal type or literal union type.
   *
   * Use a string / number literal union in place of an enum.
   * Use a single string / number literal as type tags in discriminated unions.
   */
  literal<A extends string[] | number[]>(...values: A): Column<A[number]>

  /**
   * A typescript enum mapped to an INT or TEXT column .
   */
  enum<T extends EnumObject, S extends keyof T>(enumObject: T): Column<T[S]>

  /// Modifiers

  /**
   * Mark this column as being the sole or part of the tables primary key.
   *
   * Has no meaning right now and is just to document the schema
   */
  primary(): Column<T>

  /**
   * Mark this column has having a default value.
   *
   * Columns with defaults can be ommitted in insert queries (using
   * `valueWithDefaults` or `valuesWithDefaults` from `insertInto`) or require
   * an explicit `query.DEFAULT` value in inserts.
   *
   * Most useful for autogenerated id queries.
   */
  default(): Column<T | DefaultValue>

  /**
   * Make this column nullable.
   *
   * That means it can hold `null`.
   *
   * In contrast to SQL, declaring the column nullable will not result in it
   * using `null` as the default value - if you want that behaviour, eplicitly
   * mark the column as `.default()`.
   */
  null(): Column<T | null>

  /// Building Custom Column Types

  /**
   * A column which is defined by an arbitrary runtype.
   */
  type<T>(runtype: (v: unknown) => T): T

  /**
   * Apply a cast and result transformation when selecting this column.
   *
   * `cast` is an sql expression which is applied whenever the column is
   * selected. Use `t.value` to reference the selected column value.
   *
   * `resultTransformation` is a function that is called once the query has
   * been fetched on the casted result. It should return the actual result
   * value.
   *
   * Use this to define custom type casts that work through plan selects *and* JSON
   * object / array selectds & aggregations.
   *
   * For example, the builtin `date` column type uses this to extract a dates
   * unix timestamp via `EXTRACT(EPOCH FROM t.value) * 1000` and later creates
   * a Javascript Date object from the resulting timestamp. In contrast to the
   * plain node-postgres type mapping, this works when selecting date columns
   * with `selectJsonObject` (which uses json_build_object under the hood) too.
   */
  cast<I, R, V = Table<{ value: T }, {}>>(
    cast: (e: ExpressionFactory<V>, t: V) => Expression<I, V, {}>,
    resultTransformation: (value: I) => R,
  ): Column<R>
}

/**
 * Column constructor
 *
 * `sqlName` is the name of the column in the database table, e.g. `user_id`.
 */
export interface ColumnConstructor {
  (sqlName: string): Column<unknown>
}
